#!/usr/bin/env python3

import sys
import argparse
import os
import subprocess
import platform
from shutil import which

from rich.console import Console
from rich.theme import Theme

__author__ = "Shangjin Tang"
__copyright__ = "Copyright 2022 Shangjin Tang"
__license__ = "GPL"
__version__ = "1.3.0"
__email__ = "shangjin.tang@gmail.com"

ARGS = None
console = Console(theme=Theme(inherit=False))
print = console.print


class UltimateHelpFormatter(argparse.RawTextHelpFormatter,
                            argparse.ArgumentDefaultsHelpFormatter):
    pass


def get_flag_list_from_file(flag_file):
    home_dir = os.path.expanduser("~")
    curr_dir = os.getcwd()
    flag_list = list()
    while True:
        if os.path.isfile(os.path.join(curr_dir, flag_file)):
            with open(os.path.join(curr_dir, flag_file)) as f:
                flag_list = list(line.strip() for line in f.readlines()
                                 if not line.strip().startswith("#"))
                break
        if curr_dir == home_dir:
            break
        curr_dir = os.path.dirname(curr_dir)
    return flag_list


def get_auto_complete_flag_list(flag_list):
    FLAG_PATTERN = {
        '-fcoroutines': "coroutine",
        '-lbenchmark': "benchmark/\S+",
        '-ldl': "dlfcn.h",
        '-lfmt': "fmt/\S+",
        '-lgmock': "gmock/\S+",
        '-lgtest': "gtest/\S+",
        '-pthread': "pthread.h",
    }
    if which('rg'):
        for flag, pattern in FLAG_PATTERN.items():
            if flag not in flag_list:
                pattern_check_command = "rg '^#include.*<{}>'".format(pattern)
                if ARGS.file:
                    pattern_check_command += ' ' + ' '.join(ARGS.file)
                else:
                    pattern_check_command += " --type cpp"
                retval = subprocess.call(pattern_check_command,
                                         shell=True,
                                         stdout=subprocess.DEVNULL,
                                         stderr=subprocess.DEVNULL)
                if retval == 0:
                    print("add auto-detected flag [magenta]'{}'[/magenta]".
                          format(flag, pattern))
                    flag_list.append(flag)
    return flag_list


def main():
    if not ".out" in ARGS.output and '.' in ARGS.output:
        raise Exception(
            "Output file is allowed only with '.out' extension or no extension."
        )

    if not which('clang++'):
        if not which('g++'):
            raise Exception("Compiler clang++ and g++ are not found.")
        ARGS.compiler = "g++"

    flag_list = get_flag_list_from_file(ARGS.flag_file)
    flag_list = get_auto_complete_flag_list(flag_list)

    compile_command_list = [
        ARGS.compiler, " ".join(flag_list), '-o', ARGS.output
    ]

    # Generate compile command
    if ARGS.file:
        compile_command_list.extend(ARGS.file)
    else:
        compile_command_list.append(
            "$(find . -iname '*.cpp' -or -iname '*.cc')")
    compile_command = ' '.join(compile_command_list)

    # Get run command
    run_command = './' + ARGS.output

    merged_commands_list = [compile_command, run_command]

    # Get clean command (optional)
    if ARGS.clean_output:
        clean_command = "rm ./{}".format(ARGS.output)
        if platform.system() == "Darwin" and '-g' in ARGS.flags.split():
            clean_command = "rm -rf ./{}".format(ARGS.output) + "{,.dSYM}"
        merged_commands_list.append(clean_command)

    # compile + run + clean
    merged_commands = ' && '.join(merged_commands_list)

    print("[green]{}[/green]".format(merged_commands))
    print('-' * 70)
    os.system(merged_commands)
    print('-' * 70)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(formatter_class=UltimateHelpFormatter)
    parser.add_argument(
        'file',
        nargs='*',
        type=str,
        action='extend',
        help=
        "file(s) to compile\nif not specified, use all cpp files under current directory\n"
    )
    parser.add_argument(
        '--compiler',
        default='clang++',
        choices=['clang++', 'g++'],
        help="compiler to use; if clang++ is not installed, use g++\n")
    parser.add_argument(
        '-f',
        '--flag_file',
        default=".rcxxflags",
        help="compile flag file (recursively find up to user home dir)\n")
    parser.add_argument('-o',
                        '--output',
                        default='a.out',
                        help="output executable file name\n")
    parser.add_argument('-c',
                        '--clean_output',
                        default=False,
                        action='store_true',
                        help="clean output after run\n")
    ARGS = parser.parse_args()
    try:
        main()
    except KeyboardInterrupt:
        print('Interrupted')
        try:
            sys.exit(0)
        except SystemExit:
            os._exit(0)
