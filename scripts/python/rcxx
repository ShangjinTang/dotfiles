#!/usr/bin/env python3

import argparse
import os
import platform
import subprocess
import sys
from shutil import which

from rich.console import Console
from rich.theme import Theme

__author__ = "Shangjin Tang"
__copyright__ = "Copyright 2023 Shangjin Tang"
__license__ = "GPL"
__version__ = "1.4.0"
__email__ = "shangjin.tang@gmail.com"

console = Console(theme=Theme(inherit=False))
cprint = console.print

FLAG_PATTERN = {
    "-fcoroutines": "coroutine",
    "-lbenchmark": "benchmark/\S+",  # pylint: disable=anomalous-backslash-in-string
    "-ldl": "dlfcn.h",
    "-lfmt": "fmt/\S+",  # pylint: disable=anomalous-backslash-in-string
    "-lgmock": "gmock/\S+",  # pylint: disable=anomalous-backslash-in-string
    "-lgtest": "gtest/\S+",  # pylint: disable=anomalous-backslash-in-string
    "-pthread": "pthread.h",
}


class UltimateHelpFormatter(
    argparse.RawTextHelpFormatter, argparse.ArgumentDefaultsHelpFormatter
):
    pass


def get_flag_list_from_file(flag_file):
    home_dir = os.path.expanduser("~")
    curr_dir = os.getcwd()
    flag_list = []
    while True:
        if os.path.isfile(os.path.join(curr_dir, flag_file)):
            with open(os.path.join(curr_dir, flag_file), encoding="UTF-8") as f:
                flag_list = list(
                    line.strip()
                    for line in f.readlines()
                    if not line.strip().startswith("#")
                )
                break
        if curr_dir in (home_dir, "/"):
            break
        curr_dir = os.path.dirname(curr_dir)
    return flag_list


def get_auto_complete_flag_list(file, flag_list):
    if which("rg"):
        for flag, pattern in FLAG_PATTERN.items():
            if flag not in flag_list:
                pattern_check_command = f"rg '^#include.*<{pattern}>'"
                if file:
                    pattern_check_command += " " + " ".join(file)
                else:
                    pattern_check_command += " --type cpp"
                retval = subprocess.call(
                    pattern_check_command,
                    shell=True,
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL,
                )
                if retval == 0:
                    cprint(f"add auto-detected flag [magenta]'{flag}'[/magenta]")
                    flag_list.append(flag)
    return flag_list


def main(args):
    if not ".out" in args.output and "." in args.output:
        raise ValueError(
            "Output file is allowed only with '.out' extension or no extension."
        )

    if not which("clang++"):
        if not which("g++"):
            raise EnvironmentError("Compiler clang++ / g++ not found.")
        args.compiler = "g++"

    flag_list = get_flag_list_from_file(args.flag_file)
    flag_list = get_auto_complete_flag_list(args.file, flag_list)

    compile_command_list = [args.compiler, " ".join(flag_list), "-o", args.output]

    # Generate compile command
    if args.file:
        # Specify type for file without extension. See: `man g++` -> search "-x language"
        if not all(file.endswith(".cpp") or file.endswith(".cc") for file in args.file):
            compile_command_list.extend(["-x", "c++"])
        compile_command_list.extend(args.file)
    else:
        compile_command_list.append("$(find . -iname '*.cpp' -or -iname '*.cc')")
    compile_command = " ".join(compile_command_list)

    # Get run command
    run_command = f"./{args.output}"

    merged_commands_list = [compile_command, run_command]

    # Get clean command (optional)
    if args.clean_output:
        clean_command = f"rm ./{args.output}"
        if platform.system() == "Darwin" and "-g" in args.flags.split():
            clean_command = f"rm -rf ./{args.output}" + "{,.dSYM}"
        merged_commands_list.append(clean_command)

    # compile + run + clean
    merged_commands = " && ".join(merged_commands_list)

    cprint(f"[green]{merged_commands}[/green]")
    print("-" * 70)
    os.system(merged_commands)
    print("-" * 70)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(formatter_class=UltimateHelpFormatter)
    parser.add_argument(
        "file",
        nargs="*",
        type=str,
        action="extend",
        help="file(s) to compile\nif not specified, use all cpp files under current directory\n",
    )
    parser.add_argument(
        "--compiler",
        default="clang++",
        choices=["clang++", "g++"],
        help="compiler to use; if clang++ is not installed, use g++\n",
    )
    parser.add_argument(
        "-f",
        "--flag_file",
        default=".rcxxflags",
        help="compile flag file (recursively find up to user home dir)\n",
    )
    parser.add_argument(
        "-o", "--output", default="a.out", help="output executable file name\n"
    )
    parser.add_argument(
        "-c",
        "--clean_output",
        default=False,
        action="store_true",
        help="clean output after run\n",
    )
    try:
        main(parser.parse_args())
    except KeyboardInterrupt:
        print("Interrupted")
        try:
            sys.exit(0)
        except SystemExit:
            os._exit(0)
