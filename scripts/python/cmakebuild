#!/usr/bin/env python3

import argparse
import logging
import multiprocessing
import os
import subprocess
import sys
from shutil import which

from packaging import version
from rich.console import Console
from rich.theme import Theme

__author__ = "Shangjin Tang"
__copyright__ = "Copyright 2023 Shangjin Tang"
__license__ = "GPL"
__version__ = "1.4.0"
__email__ = "shangjin.tang@gmail.com"

console = Console(theme=Theme(inherit=False))
cprint = console.print

LOGGING_FORMAT = "%(asctime)s [%(levelname)s] %(filename)s:%(lineno)d - %(message)s"
LOGGING_DATEFMT = "%Y-%m-%d %H:%M:%S"
logging.basicConfig(
    level=logging.INFO,
    format=LOGGING_FORMAT,
    datefmt=LOGGING_DATEFMT,
)


class UltimateHelpFormatter(
    argparse.RawTextHelpFormatter, argparse.ArgumentDefaultsHelpFormatter
):
    pass


def is_version_greater_or_equal(version_string: str, target_version: str) -> bool:
    try:
        source_version = version.parse(version_string)
        target_version = version.parse(target_version)
        return source_version >= target_version
    except version.InvalidVersion:
        return False


def get_version(
    command: str, version_arg: str = "--version", extract_field: int = -1
) -> str:
    try:
        result = subprocess.run(
            [command, version_arg], capture_output=True, text=True, check=True
        )
        output_lines = result.stdout.strip().split("\n")
        version_line = output_lines[0]
        version = version_line.split(" ")[extract_field]
        return version
    except (FileNotFoundError, subprocess.CalledProcessError):
        return ""


def check_conan_version(required_version: str) -> bool:
    if conan_version := get_version("conan"):
        if is_version_greater_or_equal(conan_version, required_version):
            cprint(f"conan version {conan_version} >= {required_version}")
            return True
        else:
            cprint(f"conan version {conan_version} < {required_version}")
            return False
    else:
        raise EnvironmentError("conan is not found or an error occurred.")


def validate_conan_version(required_version: str):
    if not check_conan_version(required_version):
        raise EnvironmentError(f"conan version < {required_version}")


def validate_vcpkg_install():
    if vcpkg_version := get_version("vcpkg"):
        cprint(f"vcpkg version {vcpkg_version}")
    else:
        raise EnvironmentError("Vcpkg is not found or an error occurred.")

    if os.environ.get("VCPKG_ROOT") is None:
        raise EnvironmentError("$VCPKG_ROOT is not set")


def check_cmake_version(required_version: str) -> bool:
    if cmake_version := get_version("cmake"):
        if is_version_greater_or_equal(cmake_version, required_version):
            print(f"cmake version {cmake_version} >= {required_version}")
            return True
        else:
            print(f"cmake version {cmake_version} < {required_version}")
            return False
    else:
        raise EnvironmentError("cmake is not found or an error occurred.")


def validate_cmake_version(required_version: str):
    if not check_cmake_version(required_version):
        raise EnvironmentError(f"cmake version < {required_version}")


# return True if:
#   either: conanfile.txt is newer than CMakeUserPresets.json
#   or: CMakeUserPresets.json doesn't exist
#   or: build/ doesn't exist
def should_run_conan_install() -> bool:
    conanfile_path = "conanfile.txt"
    cmake_presets_path = "CMakeUserPresets.json"
    build_path = "build"

    if not os.path.exists(build_path):
        return True

    if not os.path.exists(cmake_presets_path):
        return True

    conanfile_mtime = os.path.getmtime(conanfile_path)
    cmake_presets_mtime = os.path.getmtime(cmake_presets_path)

    return conanfile_mtime > cmake_presets_mtime


def install_conan_packages(config: str):
    try:
        if should_run_conan_install():
            print("Install conan packages")
            subprocess.run(
                ["conan", "install", ".", "-s", f"build_type={config}"],
                check=True,
                cwd=os.getcwd(),
            )
    except (FileNotFoundError, subprocess.CalledProcessError):
        raise EnvironmentError("Install conan packages failed")


def auto_complete_flags(flags: str, config: str) -> str:
    if "-DCMAKE_EXPORT_COMPILE_COMMANDS" not in flags:
        flags += " -DCMAKE_EXPORT_COMPILE_COMMANDS=1"
    if "-DCMAKE_BUILD_TYPE" not in flags:
        flags += f" -DCMAKE_BUILD_TYPE={config}"
    return flags


def get_third_party_package_manager() -> str:
    is_conan = os.path.exists(os.path.join(os.getcwd(), "conanfile.txt"))
    is_vcpkg = os.path.exists(os.path.join(os.getcwd(), "vcpkg.json"))
    if is_conan and is_vcpkg:
        raise EnvironmentError(
            "Both vcpkg and conan configuration files are here, please remove one."
        )
    if is_vcpkg:
        return "vcpkg"
    if is_conan:
        return "conan"
    return ""


def main(args):
    run_with_conan_preset = (
        args.conan_preset
    )  # This requires cmake >= 3.23. If it's set to False, we always use lagacy conan_toolchain build
    if not which("cmake"):
        raise EnvironmentError("cmake is not found. Please install it first.")

    complete_flags = auto_complete_flags(args.flags, args.config)
    compile_command = "cmake"
    run_with_conan = False

    if get_third_party_package_manager() == "conan":
        validate_conan_version("2.0")
        install_conan_packages(args.config)
        args.output = f"build/{args.config}"
        if run_with_conan_preset and check_cmake_version("3.23"):
            compile_command += f" --preset conan-{args.config.lower()}"
            run_with_conan_preset = True
        else:
            validate_cmake_version("3.15")
            compile_command += f" -S . -B {args.output} -DCMAKE_TOOLCHAIN_FILE={args.output}/generators/conan_toolchain.cmake"
            run_with_conan_preset = False
        run_with_conan = True
    elif get_third_party_package_manager() == "vcpkg":
        validate_vcpkg_install()
        validate_cmake_version("3.15")
        compile_command += f" -S . -B {args.output} -DCMAKE_TOOLCHAIN_FILE={os.environ.get('VCPKG_ROOT')}/scripts/buildsystems/vcpkg.cmake"
    else:
        compile_command += f" -S . -B {args.output}"

    merged_commands_list = []
    if complete_flags:
        compile_command += " " + complete_flags
        merged_commands_list.append(compile_command)
        # Copy compile_commands.json to current directory
        if "-DCMAKE_EXPORT_COMPILE_COMMANDS=1" in complete_flags:
            copy_compdb_command = f"cp {args.output}/compile_commands.json ."
            merged_commands_list.append(copy_compdb_command)

    if run_with_conan_preset:
        merged_commands_list.append(
            f"cmake --build --preset conan-{args.config.lower()} -j {args.jobs}"
        )
        if args.target != "all":
            merged_commands_list.append(
                f"cmake --build --preset conan-{args.config.lower()} --target {args.target} -j {args.jobs}"
            )
    else:
        merged_commands_list.append(
            f"cmake --build {args.output} --config {args.config} -j {args.jobs}"
        )
        if args.target != "all":
            merged_commands_list.append(
                f"cmake --build {args.output} --target {args.target} --config {args.config} -j {args.jobs}"
            )

    # Get clean command (optional)
    if args.clean_output:
        output_top_dir = args.output.split("/")[0]
        clean_command = f"rm -r ./{output_top_dir}"
        if run_with_conan:
            clean_command += " CMakeUserPresets.json"
        merged_commands_list.append(clean_command)

    # cmake + copy compdb + clean
    merged_commands = " && ".join(merged_commands_list)

    cprint(f"[magenta]{merged_commands}[/magenta]")
    cprint("-" * 70)
    os.system(merged_commands)
    cprint("-" * 70)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(formatter_class=UltimateHelpFormatter)
    parser.add_argument(
        "-t", "--target", default="all", help="target command for cmake"
    )
    parser.add_argument(
        "-f",
        "--flags",
        default="-DCMAKE_EXPORT_COMPILE_COMMANDS=1",
        help="compile flags\n",
    )
    parser.add_argument(
        "-o", "--output", default="build", help="cmake output directory\n"
    )
    parser.add_argument(
        "--config", default="Debug", help="cmake config type (default: Debug)\n"
    )
    parser.add_argument(
        "-c",
        "--clean_output",
        default=False,
        action="store_true",
        help="clean output directory after execution\n",
    )
    parser.add_argument(
        "-j",
        "--jobs",
        default=f"{multiprocessing.cpu_count()}",
        help="parallel thread count for make\n",
    )
    parser.add_argument(
        "--conan_preset",
        default=False,
        action="store_true",
        help="use cmake --preset with conan\n",
    )
    try:
        main(parser.parse_args())
    except KeyboardInterrupt:
        cprint("Interrupted")
        try:
            sys.exit(0)
        except SystemExit:
            os._exit(0)
